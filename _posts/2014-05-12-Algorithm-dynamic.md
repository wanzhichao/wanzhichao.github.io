---
layout: post
title: "动态规划算法"
description: "动态规划"
keywords: "动态规划"
category: 算法
tags: [动态规划]
---
{% include JB/setup %}

###动态规划算法(拒绝暴力，提倡和谐）

动态算法: 自顶向下的分析，自底向上的计算，每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。似解。

<!-- more -->

####基本思想与策略

基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。

由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。

与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解

####适用的情况

能采用动态规划求解的问题的一般要具有3个性质

    最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
    无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。
    有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。

####动态规划算法的基本步骤

划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。

确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。

确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。

寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。


实际应用中可以按以下几个简化的步骤进行设计：

    （1）分析最优解的性质，并刻画其结构特征。
    （2）递归的定义最优解。
    （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值
    （4）根据计算最优值时得到的信息，构造问题的最优解

![背包问题](/assets/images/backpack.png)

####算法实现说明

动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。

使用动态规划求解问题，最重要的就是确定动态规划三要素：
  
  （1）问题的阶段
  （2）每个阶段的状态
  （3）从前一个阶段转化到后一个阶段之间的递推关系。

递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。
确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。

具体分析http://acm.hdu.edu.cn/showproblem.php?pid=1159

####案例分析:Common Subsequence(最长公共子序列问题)

![动态规划路径](/assets/images/path.png)

####算法实现code

    #include<iostream>
    #include<string>
    #include<stdio.h>
    #define Max 100
    using namespace std;
    int size(char *s)
    {
      int len=0;
      while(*s!='\0')
      {
         len++;
         s=s+1;
      }
      return len;
    }
    int main(int argc, char* argv[])
    {
      int i,j;
      int len1,len2;
      int matricx[Max][Max];
      char s1[80],s2[80];
      while(scanf("%s %s",s1,s2) != EOF)
      {
        len1=size(s1);
        len2=size(s2);
        for(i=0;i<=len2;i++)
        {
          matricx[i][0]=0;
        }
        for(i=0;i<=len1;i++)
        {
            matricx[i][0]=0;
        }
        for(i=1;i<=len1;i++)
        {
          for(j=1;j<=len2;j++)
          {
              if(s1[i-1]==s2[j-1])
              {
                  matricx[i][j]=matricx[i-1][j-1]+1;
              }
              else
              {
                  matricx[i][j]=(matricx[i-1][j]>matricx[i][j-1])?matricx[i-1][j]:matricx[i][j-1];
              }
          }
        }
        cout<<matricx[len1][len2]<<endl;
      }
    }